# TODO

## Immediate Follow-Up (Current Session)

1. Verify Create User lookup on production after latest deploy:
   - Confirm `/api/employees` returns employee rows (not 503).
   - Confirm typing in modal filters dropdown list in real time and selecting a row auto-fills Employee ID.
2. Verify session persistence across navigation:
   - Login once, navigate between pages, confirm no repeated login prompts or `401 Not logged in`.
3. Validate employee directory config on server:
   - Confirm `EMPLOYEE_API_BASE_URL`, `EMPLOYEE_API_TOKEN`, `EMPLOYEE_API_AUTH_HEADER`, `EMPLOYEE_API_AUTH_SCHEME` in service env.
   - Confirm `/api/employees/status` shows healthy cache/error state.
4. Clean VS Code Python environments warning:
   - Re-select interpreter for repo and verify package refresh (`python -m pip list`) no longer errors in extension UI.

## Independent

1. Audit trail: record who changed status/extended/forced returns with timestamps.
2. Notifications: simple email/SMS reminders for upcoming due date and overdue items.
3. Warehouse location assignment bug: in Warehouse view, clicking a location and pressing "Edit Location" opens the modal, but unassigned tools cannot be selected and search returns no results when typing and searching.
   - Repro: Warehouse -> click location -> Edit Location -> try selecting unassigned tool / type in search.
   - Expected: unassigned tools list should load, search should filter, and selected tool should be assignable to the location.
4. Admin user control page fix: populate with all personnel from Employee API and allow per-user role assignment plus PIN code setup/update.
   - Requirement: every employee should be present in the admin user list.
   - Requirement: admin must be able to set role and PIN for each employee.

## Dependent

### Phase 1 - DB/API First

1. Employee sync from Employee API: import/sync employee list and use employee IDs as the only valid renter/reserver identities.
   - Predecessor: None (required before final notification and identity flows)
   - Status: Deferred until API hash/credentials are available.

### Phase 1b - ReadUnit Data Import (Two-Level Model + New Numbering)

1. Define and lock import rules before coding.
   - Predecessor: None
   - Deliverable: approved mapping spec from ReadUnit sheets to current two-level structure (`Tools` + `ToolInstances`).
   - Rule: ReadUnit data must be transformed to fit existing structure; no ReadUnit-shaped tables in production model.
   - Rule: every imported tool must receive a new registration number from current numbering scheme (same pattern generated by current app, e.g. `SP<year>-<seq>`).
2. Build staging import (raw ingest only, no writes to production tables).
   - Predecessor: Step 1
   - Scope: ingest all relevant sheets from `ReadUnit_Backup_1-1442.xlsx` into staging records with source trace fields.
   - Include: source row id/hash, source device id, source RFID/device code, source status, source dates, source owner/location fields.
3. Normalize and validate source keys and dates.
   - Predecessor: Step 2
   - Checks: key completeness, duplicate detection, parse validity for `Test date`/`Next test date`, and interval consistency.
   - Output: validation report (importable rows, warnings, blocked rows, exact reasons).
4. Build deterministic two-level mapping set.
   - Predecessor: Step 3
   - Level 1 (`Tools`): group by stable catalog identity (device group/type/manufacturer/description mapping).
   - Level 2 (`ToolInstances`): create one instance per physical ReadUnit device row; preserve source trace to parent tool mapping.
   - Requirement: mapping must be reproducible (same input -> same grouping result).
5. Implement numbering strategy for import.
   - Predecessor: Step 4
   - Requirement: assign new `Tool.SerialNumber` for every imported tool via current registration generator (no carry-over of legacy ReadUnit IDs as primary number).
   - Requirement: generate instance serials from current instance scheme tied to the newly assigned tool number.
   - Requirement: store legacy identifiers (`Device ID`, RFID, old serials) as reference metadata only.
6. Define status conversion with allocation safety.
   - Predecessor: Step 4
   - Map ReadUnit statuses into current operational statuses so non-ready items cannot be allocated.
   - Include due-date rule against `Next test date` to prevent expired assets entering `Available`.
   - Preserve original ReadUnit status in trace metadata/audit notes.
7. Dry-run import end-to-end with no production writes.
   - Predecessor: Steps 5-6
   - Output: counts for tools created, instances created, skipped rows, conflicts, and collision resolution summary.
   - Acceptance gate: zero unclassified statuses and zero unresolved key collisions.
8. Execute transactional production import (idempotent).
   - Predecessor: Step 7 approved
   - Order: create/update Tools first, then ToolInstances, then optional history/compliance records.
   - Requirement: rerun-safe logic (no duplicate creation on retry).
9. Post-import reconciliation and sign-off.
   - Predecessor: Step 8
   - Verify: row-count reconciliation vs staging, random sample checks, status safety checks, and numbering continuity.
   - Deliverable: final import report and rollback/repair plan for any residual exceptions.
10. Build certification/inspection history scaffolding (system-native + ReadUnit-imported).
   - Predecessor: Steps 4-6 (mapping and status rules finalized)
   - Scope: establish a consistent history model and API flow for inspection/certification events linked to `ToolInstances` (and `Tools` where needed).
   - Requirement: support writes from current system operations (new inspections/cert updates) and batch inserts from ReadUnit log/history sources.
   - Requirement: preserve event provenance (`sourceSystem`, source identifiers, import batch id, imported-at timestamp, operator/system actor).
   - Requirement: normalize event semantics (`tested`, `passed`, `failed`, `quarantine`, `next due`) so imported and native events are queryable in one timeline.
   - Acceptance: timeline query returns mixed native + imported events in chronological order with no source ambiguity.

### Phase 2 - UI/Operations

1. Simple warehouse Pickup/Return screen integration: operational entry point that uses the checklist flows and photo capture in warehouse context.
   - Predecessor: Incoming and Outgoing tablet checklist flows
2. Reservation receipt/communication UX: after reservation submit, show confirmation details (reservation number) and provide downloadable/printable receipt; after approve/reject, surface outbound notification status/details.
   - Predecessor: Phase 1 reservation decision API (completed), Employee sync from Employee API
3. Checklist photo persistence: store pickup/return checklist photos in backend records (not only local UI preview) and surface them for later lookup/audit.
   - Predecessor: Incoming/Outgoing checklist flows (completed)

### Phase 3 - Accounting

1. Weekly accounting notification job: send accounting a weekly report of invoiceable rental items/cases with rental duration, per-line amount, ledger/case breakdown, and case totals.
   - Predecessor: Phase 1 pricing integrity (completed)
   - Note: report format/details can be refined later; automated weekly collection/delivery is the priority.
2. Weekly accounting integration for partial flows: bill only picked items for active rental duration, stop billing returned lines at receive date, and include replacement charge for not-returned/lost lines.
   - Predecessor: Weekly accounting notification job, Phase 1 rental line lifecycle + transaction APIs (completed)
3. Reservation communication delivery: send employee-facing approval/rejection notifications including reservation/rental number, reason (for reject), and order details (for approve); support email first and optional SMS later.
   - Predecessor: Phase 1 reservation decision API (completed), Reservation approval/rejection UX (completed), Employee sync from Employee API
4. Shortage and partial-dispatch accounting treatment: replacement/procure lines remain non-invoiceable until picked and marked In Rental; weekly statements must exclude pending shortage lines.
   - Predecessor: Weekly accounting integration for partial flows, Phase 1 shortage/partial-dispatch rules (completed)
